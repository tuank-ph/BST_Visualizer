<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Title</title>
    <link rel="stylesheet" href="assets/home.css" />
    <link rel="stylesheet" href="assets/default-styles.css">
</head>
<body>

    <div id="credit">
        <h1>BINARY SEARCH TREE</h1>
        <h1>EULER - HAMILTON: PATH / CIRCUIT</h1>
        <h2 style="margin-bottom: 10px">NHÓM 3</h2>
        <h4>Phạm Tuấn Khanh
        Trần Gia Huy
        Lê Nguyễn Minh Khôi <span style="font-weight: bold; color: dodgerblue">HSGQG</span>
        Nguyễn Lê Thái Dương
        Đoàn Thiên An
        </h4>
    </div>

    <div id="theory-container">
        <h1>Cơ sở lý thuyết</h1>

        <h2>Giới thiệu về đường đi và chu trình Euler</h2>
        <p>Đường đi Euler là một đường đi trên đồ thị (vô hướng/có hướng) đi qua tất cả các cạnh đúng chính xác 1 lần duy nhất. Trong hình 1.1, một đường đi Euler là: 0-1-2-0-3-4:</p>
        <!-- Image -->
        <div class="image-container">
            <img src="assets/home-images/pic1.png" alt="Hình 1.1: Đường đi Euler có hướng">
            <p><strong>Hình 1.1:</strong> Đường đi Euler (đồ thị có hướng)</p>
        </div>
        <p>Trong hình 1.2, một đường đi Euler là: 0-1-2-3:</p>
        <div class="image-container">
            <img src="./assets/home-images/pic5.jpg" alt="Hình 1.2: Đường đi Euler vô hướng">
            <p><strong>Hình 1.2:</strong> Đường đi Euler (đồ thị vô hướng)</p>
        </div>

        <p>Chu trình Euler là một đường đi Euler trên đồ thị (vô hướng/có hướng) thỏa mãn điểm đầu và điểm kết thúc đều cùng là một đỉnh. Trong hình 2.1, một chu trình Euler là: 0-1-2-0-3-4-0:</p>
        <!-- Image -->
        <div class="image-container">
            <img src="./assets/home-images/pic2.png" alt="Hình 2.1: Chu trình Euler có hướng">
            <p><strong>Hình 2.1:</strong> Chu trình Euler (đồ thị có hướng)</p>
        </div>
        <p>Trong hình 2.2, một chu trình Euler là: 0-1-2-3-0:</p>
        <div class="image-container">
            <img src="./assets/home-images/pic6.jpg" alt="Hình 2.2: Chu trình Euler vô hướng">
            <p><strong>Hình 2.2:</strong> Chu trình Euler (đồ thị có hướng)</p>
        </div>

        <h2>Giới thiệu về đường đi và chu trình Hamilton</h2>
        <p>Đường đi Hamilton khác một chút so với đường đi Euler, là một đường đi trên đồ thị (vô hướng/có hướng) đi qua tất cả các đỉnh đúng chính xác 1 lần duy nhất. Trong hình 3.1, một đường đi Hamilton là: 0-1-5-2-3-4:</p>
        <!-- Image -->
        <div class="image-container">
            <img src="./assets/home-images/pic3.png" alt="Hình 3.1: Đường đi Hamilton có hướng">
            <p><strong>Hình 3.1:</strong> Đường đi Hamilton (đồ thị có hướng)</p>
        </div>
        <p>Trong hình 3.2, một đường đi Hamilton là: 3-0-2-1:</p>
        <div class="image-container">
            <img src="./assets/home-images/pic7.jpg" alt="Hình 3.1: Đường đi Hamilton vô hướng">
            <p><strong>Hình 3.2:</strong> Đường đi Hamilton (đồ thị vô hướng)</p>
        </div>

        <p>Chu trình Hamilton tương tự vậy, cũng là một đường đi Hamilton trên đồ thị (vô hướng/có hướng) nhưng thỏa mãn điều kiện xuất phát và kết thúc cùng 1 điểm, ở đây là điểm 0. Trong hình 4.1, một chu trình Hamilton là: 0-1-5-2-3-4-0:</p>
        <!-- Image -->
        <div class="image-container">
            <img src="./assets/home-images/pic4.png" alt="Hình 4.1: Chu trình Hamilton">
            <p><strong>Hình 4.1:</strong> Chu trình Hamilton (đồ thị có hướng)</p>
        </div>
        <p>Trong hình 4.2, một chu trình Hamilton là: 3-0-2-1:</p>
        <div class="image-container">
            <img src="./assets/home-images/pic8.jpg" alt="Hình 4.2: Chu trình Hamilton">
            <p><strong>Hình 4.2:</strong> Chu trình Hamilton (đồ thị vô hướng)</p>
        </div>

        <h1>Các thuật toán tìm kiếm đường đi & chu trình Euler/Hamilton</h1>

        <h2>Thuật toán Hierholzer (Euler)</h2>

        <h3>Giới thiệu</h3>
        <p>Thuật toán Hierholzer là một phương pháp kinh điển để tìm chu trình Euler (Eulerian Circuit) trong đồ thị. Nó được đặt theo tên của nhà toán học Carl Hierholzer. Thuật toán này áp dụng được cho cả đồ thị vô hướng và có hướng, với điều kiện đồ thị thỏa mãn tiêu chí tồn tại chu trình Euler.</p>
        <p>Ý tưởng tổng quan của thuật toán: dựa trên việc xây dựng và mở rộng các chu trình nhỏ cho đến khi tất cả các cạnh của đồ thị được duyệt. Điểm đặc biệt của thuật toán là cách nó xử lý các cạnh từng bước một, tạo ra một chu trình lớn duy nhất từ các chu trình con. Độ phức tạp của thuật toán là O(E), với E là số cạnh.</p>

        <h3>Thuật toán chi tiết</h3>
        <p><strong>Đầu vào:</strong></p>
        <ul>
            <li>Một đồ thị G=(V,E).</li>
            <li>Một đỉnh bắt đầu <em>startNode</em>.</li>
        </ul>
        <p><strong>Quy trình:</strong></p>
        <ol>
            <li>Khởi tạo:
                <ul>
                    <li>Dùng một ngăn xếp <code>currPath</code> để lưu đường đi hiện tại.</li>
                    <li>Dùng một danh sách <code>circuit</code> để lưu chu trình/đường đi cuối cùng.</li>
                </ul>
            </li>
            <li>Duyệt đồ thị:
                <ul>
                    <li>Bắt đầu từ <em>startNode</em>, thêm vào ngăn xếp <code>currPath</code>.</li>
                    <li>Nếu đỉnh hiện tại có cạnh chưa được thăm, chọn cạnh cuối trong danh sách kề và chuyển sang đỉnh kế tiếp (xóa cạnh đã thăm khỏi đồ thị).</li>
                    <li>Nếu không còn cạnh nào để đi, đưa đỉnh hiện tại vào <code>circuit</code> và quay lại đỉnh trước đó (pop từ <code>currPath</code>).</li>
                </ul>
            </li>
            <li>Lặp lại đến khi tất cả các cạnh được thăm.</li>
        </ol>
        <p><strong>Đầu ra:</strong> Một danh sách các đỉnh theo thứ tự đi của chu trình/đường đi Euler.</p>

        <h4>Code minh họa (có hướng)</h4>
        <pre class="code-block"><code>
void findEulerian(int startNode) {
    stack&lt;int&gt; currPath;
    vector&lt;int&gt; circuit;
    currPath.push(startNode);

    while (!currPath.empty()) {
        int current = currPath.top();
        if (!adj[current].empty()) {
            int next = adj[current].back();
            adj[current].pop_back();
            currPath.push(next);
        } else {
            circuit.push_back(current);
            currPath.pop();
        }
    }

    reverse(circuit.begin(), circuit.end());
}
        </code></pre>

        <h4>Code minh họa (vô hướng)</h4>
        <pre class="code-block"><code>
void findEulerian(int startNode) {
    stack&lt;int&gt; currPath;
    currPath.push(startNode);
    while (!currPath.empty()) {
        int current = currPath.top();
        if (!adj[current].empty()) {
            int next = adj[current].back();
            adj[current].pop_back();
            adj[next].erase(find(adj[next].begin(), adj[next].end(), current));
            currPath.push(next);
        } else {
            circuit.push_back(current);
            currPath.pop();
        }
    }

    reverse(circuit.begin(), circuit.end());
}
        </code></pre>

        <h2>Quay lui (Hamilton)</h2>

        <h3>Giới thiệu</h3>
        <p>Khác với tìm kiếm chu trình hay đường đi Euler, hiện tại vẫn chưa có thuật toán nào tối ưu cho việc tìm kiếm đường đi và chu trình Hamilton. Vậy nên ở đây, chúng ta sẽ sử dụng quay lui hay backtracking với độ phức tạp O(V.V!) với V là số đỉnh của đồ thị.</p>
        <p>Ý tưởng tổng quan: Duyệt qua tất cả các đỉnh làm đỉnh bắt đầu. Từ mỗi đỉnh này, duyệt qua các đỉnh liền kề với nó và tìm tất cả các con đường khả thi.</p>

        <h3>Thuật toán chi tiết</h3>
        <p><strong>Đầu vào:</strong></p>
        <ul>
            <li>Một đồ thị G=(V,E).</li>
            <li>Một đỉnh bắt đầu <em>node</em>.</li>
        </ul>
        <p><strong>Quy trình:</strong></p>
        <ol>
            <li>Khởi tạo:
                <ul>
                    <li>Dùng một mảng <code>visited[]</code>.</li>
                    <li>Dùng một danh sách <code>path</code> để lưu chu trình/đường đi cuối cùng.</li>
                </ul>
            </li>
            <li>Duyệt đồ thị:
                <ul>
                    <li>Bắt đầu từ <em>node</em>, duyệt sang các đỉnh liền kề.</li>
                    <li>Nếu gặp một đỉnh chưa đánh dấu, đánh dấu nó lại rồi đi tiếp.</li>
                    <li>Lặp lại quá trình này cho tới khi tìm được chu trình/đường đi.</li>
                </ul>
            </li>
        </ol>
        <p><strong>Đầu ra:</strong></p>
        <ul>
            <li>Nếu tìm được trả về <code>true</code>.</li>
            <li>Ngược lại, trả về <code>false</code>.</li>
        </ul>

        <h4>Code minh họa</h4>
        <pre class="code-block"><code>
bool findHamiltonianPath(int node) {
    path.push_back(node);
    visited[node] = true;
    if (path.size() == numNodes) {
        return true;
    }
    for (int neighbor : adj[node]) {
        if (!visited[neighbor]) {
            if (findHamiltonianPath(neighbor))
                return true;
        }
    }
    visited[node] = false;
    path.pop_back();
    return false;
}
        </code></pre>

        <h1>Nhận biết đường đi và chu trình Euler/Hamilton trong bài tập</h1>

        <h2>Nhận biết Euler</h2>
        <h3>Cách nhận biết</h3>
        <p>Chúng ta có thể xem xét vào các trường hợp sau để áp dụng tính chất của đường đi hay chu trình Euler:</p>
        <ul>
            <li>Nếu bài toán yêu cầu thăm tất cả các cạnh (Tính chất cơ bản của đường đi Euler).</li>
            <li>Đặc biệt, đối với các bài toán về cây như <em>Subtree Queries (CSES)</em> ta có thể xem xét lợi dụng các tính chất của đường đi Euler (đi qua hết các cạnh) lưu lại thời gian vào - ra (in - out) của đỉnh để “làm phẳng” cây. Chúng ta có thể tách ra thành hai đường đi một chiều riêng biệt thay vì một đường đi hai chiều để thỏa tính chất đường đi Euler.</li>
        </ul>

        <h3>Bài tập vận dụng (Teleporters Path – CSES)</h3>
        <p><strong>Tóm tắt đề:</strong> Tìm một đường đi Euler trên đồ thị có hướng N (N ≤ 1e5) đỉnh, M (M ≤ 2e5) cạnh. In IMPOSSIBLE nếu không thể tìm được.</p>
        <p><strong>Ý tưởng:</strong> Để tìm đường đi Euler, một phương pháp là thêm một cạnh ảo nối giữa hai đỉnh có bậc lẻ, sau đó tìm chu trình Euler. Khi hoàn thành, chỉ cần loại bỏ cạnh ảo để thu được đường đi Euler. Một cách khác để tìm đường đi Euler là sử dụng trực tiếp thuật toán tìm chu trình Euler với đỉnh bắt đầu là 1. Kết quả thu được chính là đường đi Euler của đồ thị ban đầu. Điều này xảy ra vì trong lần lặp đầu tiên, thuật toán sẽ xác định một đường đi từ đỉnh 1 đến n. Các cạnh chưa thăm còn lại trong đồ thị sẽ tạo thành các thành phần liên thông, mỗi thành phần thỏa mãn điều kiện tồn tại chu trình Euler. Thuật toán sau đó sẽ tiếp tục đệ quy trên từng đồ thị con để tìm các chu trình Euler, rồi nối chúng lại để tạo thành đường đi Euler hoàn chỉnh.</p>

        <h4>Code mẫu</h4>
        <pre class="code-block"><code>
#include &lt;bits/stdc++.h&gt;

using namespace std;

const int N = 1e5 + 2, M = 2e5 + 2;

struct Edge {
    int target, id;

    Edge(int _target, int _id): target(_target), id(_id) {}
};

int n, m, in_deg[N];
vector&lt;Edge&gt; adj[N];
bool used_edge[M];

list&lt;int&gt; euler_walk(int u);

bool check() {
    if (adj[1].size() != in_deg[1] + 1 ||
        adj[n].size() != in_deg[n] - 1)
        return false;

    for (int i = 2; i &lt; n; ++i)
        if (adj[i].size() != in_deg[i])
            return false;

    return true;
}

int main() {
    cin &gt;&gt; n &gt;&gt; m;
    for (int i = 0; i &lt; m; ++i) {
        int u, v;
        cin &gt;&gt; u &gt;&gt; v;
        adj[u].emplace_back(v, i);
        ++in_deg[v];
    }
    if (!check()) {
        cout &lt;&lt; "IMPOSSIBLE";
        return 0;
    }
    adj[n].emplace_back(1, m);
    list&lt;int&gt; ans = euler_walk(1);
    if (ans.size() &lt; m + 1)
        cout &lt;&lt; "IMPOSSIBLE";
    else {
        for (auto u1 = ans.begin(), u2 = ++ans.begin(); u2 != ans.end(); ++u1, ++u2)
            if (*u1 == n && *u2 == 1) {
                for (auto i = u2; i != ans.end(); ++i)
                    cout &lt;&lt; (*i) &lt;&lt; " ";
                for (auto i = ++ans.begin(); i != u2; ++i)
                    cout &lt;&lt; (*i) &lt;&lt; " ";
                break;
            }
    }
  return 0;
}
        </code></pre>

        <h2>Nhận biết Hamilton</h2>
        <h3>Cách nhận biết</h3>
        <p>Chúng ta có thể xem xét vào các trường hợp sau để áp dụng tính chất của đường đi hay chu trình Hamilton:</p>
        <ul>
            <li>Nếu bài toán yêu cầu thăm tất cả các đỉnh (tính chất cơ bản của đường đi/chu trình Hamilton).</li>
            <li>Bài toán yêu cầu xét tính liên kết/mạng lưới của các đỉnh → ta có thể lợi dụng tính chất của đường đi Hamilton.</li>
        </ul>

        <h3>Bài tập vận dụng (Micro and Permutations – HackerEarth)</h3>
        <p><strong>Tóm tắt:</strong> Cho một đồ thị hai chiều N đỉnh M cạnh. Đếm số con đường đi qua tất cả các đỉnh đúng 1 lần duy nhất (đếm số đường Hamilton).</p>
        <p><strong>Ý tưởng:</strong> Quay lui, kiểm tra từng hoán vị của đỉnh bằng hàm check. Nếu check trả về true res++. Cuối cùng, xuất ra res – đáp án là số con đường Hamilton có trong đồ thị</p>

        <h4>Code mẫu</h4>
        <pre class="code-block"><code>
#include &lt;bits/stdc++.h&gt;
#define ll long long

using namespace std;

ll N, M;

bool check(const vector&lt;int&gt;&amp; perm, const vector&lt;vector&lt;bool&gt;&gt;&amp; adj) {
    for (int i = 0; i &lt; perm.size() - 1; ++i) {
        if (!adj[perm[i]][perm[i+1]]) {
            return false;
        }
    }
    return true;
}

int main() {
    cin &gt;&gt; N &gt;&gt; M;

    vector&lt;vector&lt;bool&gt;&gt; adj(N+1, vector&lt;bool&gt;(N+1, false));

    for (int i = 0; i &lt; M; ++i) {
        int X, Y;
        cin &gt;&gt; X &gt;&gt; Y;
        adj[X][Y] = true;
        adj[Y][X] = true;
    }

    vector&lt;int&gt; vertices(N);
    for (int i = 0; i &lt; N; ++i) {
        vertices[i] = i + 1;
    }

    int res = 0;

    do {
        if (check(vertices, adj)) {
            res++;
        }
    } while (next_permutation(vertices.begin(), vertices.end()));

    cout &lt;&lt; res &lt;&lt; '\n';

    return 0;
}
        </code></pre>
    </div>
    <div id="ui">
        <nav>
            <a class="tab active" href="./index.html"><i class="fi fi-rs-sparkles"></i><p>Documentation</p></a>
            <a class="tab" href="./binarySearchTree.html"><i class="fi fi-rs-chart-tree"></i><p>Binary Search Tree</p></a>
            <a class="tab" href="./eulerHamilton.html"><i class="fi fi-rs-chart-network"></i><p>Euler / Hamilton</p></a>
        </nav>
    </div>

<!--  <object type="text/html" data="/pages/BinarySearchTree/index.html" ></object>-->
</body>
</html>